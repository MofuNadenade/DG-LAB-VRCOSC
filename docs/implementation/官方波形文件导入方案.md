# 官方波形文件导入方案

## 概述

本文档分析了郊狼App波形格式文档和现有代码结构，制定了实现导入官方.pulse波形文件的完整方案。

## 1. 格式分析与协议兼容性

### 1.1 郊狼App波形格式结构

根据文档分析，.pulse文件采用以下结构：

```
Dungeonlab+pulse:波形描述=小节描述+section+...+section+小节描述
```

**波形描述部分**：`休息时长,速度倍率,未知参数`
- 休息时长：滑块值，与真实值（单位s）的映射关系为线性的0.1倍，即10代表1s
- 速度倍率：可接受的值为1, 2, 4
- 未知参数：默认值为16，作用尚不明确

**小节描述部分**：`频率A,频率B,小节时长,频率模式,小节开关/脉冲数据`
- 频率A：频率变化初值，取值范围0至83
- 频率B：频率变化终值，取值范围0至83（固定模式下失效）
- 小节时长：滑块值，取值范围0至99
- 频率模式：1-4，分别对应固定、节内渐变、元内渐变、元间渐变
- 小节开关：0表示禁用，1表示启用
- 脉冲数据：格式为`强度-脉冲类型,强度-脉冲类型,...`

### 1.2 数据映射关系

**频率滑块值映射**：
```javascript
const FREQ_SLIDER_VALUE_MAP = [
  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
  50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
  80, 85, 90, 95,
  100, 110, 120, 130, 140, 150, 160, 170, 180, 190,
  200, 233, 266, 300, 333, 366,
  400, 450, 500, 550,
  600, 700, 800, 900, 1000
]
```

**协议频率转换算法**：
根据郊狼情趣脉冲主机协议文档，系统支持输入值范围(10~1000)到实际频率的转换：

```javascript
// 输入值范围(10 ~ 1000)转换为波形频率(毫秒)
波形频率 = when(输入值){
    in 10..100 -> {
        输入值
    }
    in 101..600 -> {
        (输入值 - 100)/5 + 100
    }
    in 601..1000 -> {
        (输入值 - 600)/10 + 200
    }
    else -> {
        10
    }
}
```

**频率范围限制**：
- B0指令中频率值范围：10~240（协议数值，无单位）
- 需要将.pulse文件的10~1000ms映射到10~240协议数值
- 超出范围的值会被设备忽略

**小节时长滑块值映射**：
```javascript
const SECTION_TIME_MAP = [
  0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3, 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4, 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8, 4.9,
  5, 5.2, 5.4, 5.6, 5.8, 6, 6.2, 6.4, 6.6, 6.8, 7, 7.2, 7.4, 7.6, 7.8,
  8, 8.5, 9, 9.5,
  10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
  20, 23.4, 26.6, 30, 33.4, 36.6,
  40, 45, 50, 55,
  60, 70, 80, 90,
  100, 120, 140, 160, 180,
  200, 250, 300
];
```

### 1.3 协议兼容性分析

#### 1.3.1 频率映射兼容性

根据郊狼情趣脉冲主机协议文档分析，.pulse文件中的频率数据需要与协议兼容：

**频率值范围**：
- .pulse文件：频率滑块值0-83，映射到10-1000输入值
- 协议：B0指令频率值10-240（协议数值，无单位）
- 兼容性：需要将.pulse文件的10-1000输入值映射到协议的10-240数值范围

**频率转换流程**：
1. .pulse文件频率滑块值 → 输入值（通过FREQ_SLIDER_VALUE_MAP）
2. 输入值 → 协议频率值（通过协议算法转换到10-240）
3. 协议频率值 → 设备输出（通过B0指令发送）

**频率映射关系**：
- 输入值10 → 协议值10
- 输入值1000 → 协议值240
- 分段映射：根据协议算法进行转换
- 超出10-240范围的值会被设备忽略

**重要说明**：
- .pulse文件中的频率滑块值映射到的是"输入值"，不是真正的毫秒周期
- 协议文档中的"输入值范围(10~1000)"对应.pulse文件的频率滑块映射值
- 这些输入值通过协议算法转换为最终的协议频率值(10-240)

#### 1.3.2 强度映射兼容性

**强度值范围**：
- .pulse文件：强度值0-100（百分比）
- 协议：B0指令强度值0-100
- 兼容性：完全兼容，无需转换

**强度软上限**：
- 协议支持通过BF指令设置通道强度软上限（0-200）
- 导入的波形强度值会被软上限限制
- 建议在导入后检查并设置合适的软上限

## 2. 方案特性

### 2.1 脉冲元循环机制

方案正确实现了郊狼App波形格式的核心特性：

1. **脉冲元长度计算**：根据脉冲数据项数量和速度倍率计算实际长度
   - speed_multiplier=1：每个脉冲数据项代表0.1秒
   - speed_multiplier=2：每个脉冲数据项代表0.05秒（50ms）
   - speed_multiplier=4：每个脉冲数据项代表0.025秒（25ms）
   - 最小长度为0.2秒除以速度倍率

2. **循环次数计算**：使用`math.ceil(section_duration / pulse_element_duration)`计算循环次数

3. **重复播放机制**：脉冲元总是会重复完整个循环之后再停止，确保实际输出时长与设定时长一致

4. **速度倍率与播放速度对应关系**：
   - speed_multiplier=1：正常速度播放，每个脉冲数据项对应1个PulseOperation（100ms，4个25ms子步骤）
   - speed_multiplier=2：2倍速播放，每2个脉冲数据项压缩到1个PulseOperation中（100ms，4个25ms子步骤）
   - speed_multiplier=4：4倍速播放，每4个脉冲数据项压缩到1个PulseOperation中（100ms，4个25ms子步骤）

### 2.2 频率模式支持

方案完整支持所有四种频率模式，严格按照郊狼App官方格式实现。

**重要概念说明**：
- **脉冲元**：由脉冲数据定义的基础波形单位，每个脉冲数据项代表0.1s
- **小节重复**：根据小节时长，一个小节可能会重复播放多次脉冲元
- **PulseOperation**：系统内部的100ms时间单位，包含4个25ms子步骤

**频率模式区别的关键**：
- 当小节重复1次时，节内渐变和元间渐变没有区别
- 当小节重复多次时：
  - **节内渐变**：从小节开始渐变到小节结束（跨越所有重复的脉冲元）
  - **元间渐变**：从单个循环的脉冲元开始渐变到这个循环结束的脉冲元（每次重复都是独立的渐变）

#### 2.2.1 固定模式（FrequencyMode.FIXED = 1）
- **官方描述**：本小节的全部持续时间内频率恒定为频率A
- **实现方式**：所有脉冲都使用频率A，不进行任何渐变
- **适用场景**：需要稳定频率输出的波形

#### 2.2.2 节内渐变模式（FrequencyMode.SECTION_GRADIENT = 2）
- **官方描述**：本小节的全部持续时间内频率会逐渐从第一个设定值渐变到第二个设定值
- **实现方式**：在整个小节的所有脉冲中，从频率A线性渐变到频率B
- **渐变计算**：progress = pulse_index / (total_pulses - 1)
- **适用场景**：需要频率逐渐变化的波形

#### 2.2.3 元内渐变模式（FrequencyMode.ELEMENT_GRADIENT = 3）
- **官方描述**：本小节每个脉冲元的持续时间内频率逐渐从第一个设定值渐变到第二个设定值，也就是频率在每个脉冲元内周期性变化
- **正确理解**：在PulseOperation的4个25ms子步骤内从频率A渐变到频率B
- **实现方式**：
  - speed_multiplier=1: 4个子步骤都参与渐变（100ms内渐变）
  - speed_multiplier=2: 2个子步骤参与渐变（50ms内渐变）  
  - speed_multiplier=4: 1个子步骤，无法渐变（25ms固定频率）
- **渐变计算**：在PulseOperation内部，progress = sub_step_index / (gradient_steps - 1)
- **适用场景**：需要在每个PulseOperation内部频率渐变的波形

#### 2.2.4 元间渐变模式（FrequencyMode.ELEMENT_INTER_GRADIENT = 4）
- **官方描述**：本小节每个脉冲元内部的频率是固定的，但是第一个脉冲元的频率到最后一个脉冲元的频率会从第一个设定值渐变到第二个设定值
- **正确理解**：每个脉冲元（重复循环）内部频率固定，但不同脉冲元之间频率渐变
- **实现方式**：每个脉冲元内部频率固定，但不同脉冲元之间的频率从A渐变到B
- **渐变计算**：progress = cycle_index / (total_cycles - 1)
- **适用场景**：需要脉冲元间频率渐变的波形

### 2.3 协议兼容性

- 频率值映射：将.pulse文件的10-1000ms映射到协议的10-240数值范围
- 强度值兼容：直接使用0-100的强度值
- 范围验证：确保所有频率值在协议支持的范围内

## 3. 现有代码分析

### 3.1 数据模型

现有系统使用以下数据模型：

```python
PulseOperation = Tuple[
    WaveformFrequencyOperation,  # (freq1, freq2, freq3, freq4)
    WaveformStrengthOperation    # (strength1, strength2, strength3, strength4)
]
```

每个PulseOperation代表一个100ms的波形步骤，包含4个25ms的子步骤。

### 3.2 现有导入功能

- **文件导入**：支持JSON格式的波形文件导入
- **分享码导入**：支持DGLAB-PULSE-V1格式的分享码导入
- **数据验证**：包含完整的数据完整性检查

### 3.3 导入对话框结构

`ImportPulseDialog`类包含两个标签页：
- 文件导入标签页：处理JSON文件导入
- 分享码导入标签页：处理分享码导入

## 4. 实现方案

### 4.1 新增.pulse文件解析器

创建`src/core/pulse_file_parser.py`：

```python
"""
官方.pulse文件解析器

解析郊狼App的.pulse波形文件格式，转换为系统内部PulseOperation格式
"""

import logging
from typing import List, Tuple, Optional, Dict, Any
from dataclasses import dataclass
from enum import IntEnum

from models import PulseOperation

logger = logging.getLogger(__name__)


class FrequencyMode(IntEnum):
    """频率模式枚举"""
    FIXED = 1          # 固定
    SECTION_GRADIENT = 2  # 节内渐变
    ELEMENT_GRADIENT = 3  # 元内渐变
    ELEMENT_INTER_GRADIENT = 4  # 元间渐变


@dataclass
class PulseFileHeader:
    """脉冲文件头部信息"""
    rest_duration: float  # 休息时长（秒）
    speed_multiplier: int  # 速度倍率
    unknown_param: int    # 未知参数


@dataclass
class PulseSection:
    """脉冲小节信息"""
    freq_a: int           # 频率A
    freq_b: int           # 频率B
    section_duration: float  # 小节时长（秒）
    frequency_mode: FrequencyMode  # 频率模式
    enabled: bool         # 小节开关
    pulse_data: List[PulseDataItem]  # 脉冲数据


@dataclass
class PulseDataItem:
    """脉冲数据项"""
    intensity: int    # 强度 (0-100)
    pulse_type: int   # 脉冲类型


@dataclass
class PulseFileData:
    """脉冲文件数据"""
    header: PulseFileHeader
    sections: List[PulseSection]


class PulseFileConstants:
    """脉冲文件常量定义"""
    
    # 频率滑块值映射表
    FREQ_SLIDER_VALUE_MAP = [
        10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
        50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
        80, 85, 90, 95,
        100, 110, 120, 130, 140, 150, 160, 170, 180, 190,
        200, 233, 266, 300, 333, 366,
        400, 450, 500, 550,
        600, 700, 800, 900, 1000
    ]
    
    # 小节时长滑块值映射表
    SECTION_TIME_MAP = [
        0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3, 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4, 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8, 4.9,
        5, 5.2, 5.4, 5.6, 5.8, 6, 6.2, 6.4, 6.6, 6.8, 7, 7.2, 7.4, 7.6, 7.8,
        8, 8.5, 9, 9.5,
        10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
        20, 23.4, 26.6, 30, 33.4, 36.6,
        40, 45, 50, 55,
        60, 70, 80, 90,
        100, 120, 140, 160, 180,
        200, 250, 300
    ]
    
    # 协议频率范围
    PROTOCOL_FREQ_MIN = 10
    PROTOCOL_FREQ_MAX = 240
    
    # 脉冲元最小长度（秒）
    MIN_PULSE_ELEMENT_DURATION = 0.2
    
    # 基础时间单位（秒）
    BASE_TIME_PER_ITEM = 0.1


class PulseFileParser:
    """官方.pulse文件解析器"""
    
    def parse_file(self, file_path: str) -> PulseFileData:
        """解析.pulse文件
        
        Args:
            file_path: .pulse文件路径
            
        Returns:
            PulseFileData: 脉冲文件数据
            
        Raises:
            ValueError: 文件格式错误时抛出
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().strip()
            
            return self.parse_content(content)
            
        except FileNotFoundError:
            raise ValueError(f"文件不存在: {file_path}")
        except UnicodeDecodeError:
            raise ValueError(f"文件编码错误，请确保文件为UTF-8编码: {file_path}")
        except Exception as e:
            raise ValueError(f"解析文件失败: {e}")
    
    def parse_content(self, content: str) -> PulseFileData:
        """解析.pulse文件内容
        
        Args:
            content: 文件内容字符串
            
        Returns:
            PulseFileData: 脉冲文件数据
        """
        # 检查文件格式
        if not content.startswith("Dungeonlab+pulse:"):
            raise ValueError("不是有效的.pulse文件格式")
        
        # 分离头部和小节数据
        parts = content.split("=", 1)
        if len(parts) != 2:
            raise ValueError("文件格式错误：缺少波形描述部分")
        
        header_str, sections_str = parts
        
        # 解析头部
        header = self._parse_header(header_str)
        
        # 解析小节
        sections = self._parse_sections(sections_str)
        
        return PulseFileData(header=header, sections=sections)
    
    def _parse_header(self, header_str: str) -> PulseFileHeader:
        """解析文件头部"""
        # 移除前缀
        if header_str.startswith("Dungeonlab+pulse:"):
            header_str = header_str[17:]
        
        # 解析参数
        params = header_str.split(",")
        if len(params) != 3:
            raise ValueError("波形描述参数数量错误")
        
        try:
            rest_duration_slider = int(params[0])
            speed_multiplier = int(params[1])
            unknown_param = int(params[2])
        except ValueError as e:
            raise ValueError(f"波形描述参数格式错误: {e}")
        
        # 转换休息时长为实际秒数
        rest_duration = rest_duration_slider * 0.1
        
        # 验证速度倍率
        if speed_multiplier not in [1, 2, 4]:
            raise ValueError(f"无效的速度倍率: {speed_multiplier}")
        
        return PulseFileHeader(
            rest_duration=rest_duration,
            speed_multiplier=speed_multiplier,
            unknown_param=unknown_param
        )
    
    def _parse_sections(self, sections_str: str) -> List[PulseSection]:
        """解析小节数据"""
        sections = []
        section_parts = sections_str.split("+section+")
        
        for i, section_str in enumerate(section_parts):
            if not section_str.strip():
                continue
                
            try:
                section = self._parse_section(section_str.strip())
                sections.append(section)
            except Exception as e:
                logger.warning(f"解析第{i+1}个小节失败: {e}")
                continue
        
        return sections
    
    def _parse_section(self, section_str: str) -> PulseSection:
        """解析单个小节"""
        # 分离基础参数和脉冲数据
        if "/" not in section_str:
            raise ValueError("小节格式错误：缺少脉冲数据分隔符")
        
        basic_params_str, pulse_data_str = section_str.split("/", 1)
        basic_params = basic_params_str.split(",")
        
        if len(basic_params) != 5:
            raise ValueError("小节基础参数数量错误")
        
        try:
            freq_a = int(basic_params[0])
            freq_b = int(basic_params[1])
            section_duration_slider = int(basic_params[2])
            frequency_mode = FrequencyMode(int(basic_params[3]))
            enabled = int(basic_params[4]) == 1
        except (ValueError, IndexError) as e:
            raise ValueError(f"小节参数格式错误: {e}")
        
        # 转换小节时长为实际秒数
        section_duration = self._slider_to_section_time(section_duration_slider)
        
        # 解析脉冲数据
        pulse_data = self._parse_pulse_data(pulse_data_str)
        
        return PulseSection(
            freq_a=freq_a,
            freq_b=freq_b,
            section_duration=section_duration,
            frequency_mode=frequency_mode,
            enabled=enabled,
            pulse_data=pulse_data
        )
    
    def _parse_pulse_data(self, pulse_data_str: str) -> List[PulseDataItem]:
        """解析脉冲数据"""
        if not pulse_data_str.strip():
            return []
        
        pulse_data = []
        for item in pulse_data_str.split(","):
            item = item.strip()
            if not item:
                continue
            
            if "-" not in item:
                raise ValueError(f"脉冲数据格式错误: {item}")
            
            try:
                intensity, pulse_type = item.split("-", 1)
                pulse_data.append(PulseDataItem(
                    intensity=int(intensity),
                    pulse_type=int(pulse_type)
                ))
            except ValueError as e:
                raise ValueError(f"脉冲数据项格式错误: {item}, {e}")
        
        return pulse_data
    
    def _slider_to_frequency(self, slider_value: int) -> int:
        """将频率滑块值转换为实际频率值（毫秒）"""
        if 0 <= slider_value < len(PulseFileConstants.FREQ_SLIDER_VALUE_MAP):
            return PulseFileConstants.FREQ_SLIDER_VALUE_MAP[slider_value]
        else:
            # 超出范围时使用边界值
            if slider_value < 0:
                return PulseFileConstants.FREQ_SLIDER_VALUE_MAP[0]
            else:
                return PulseFileConstants.FREQ_SLIDER_VALUE_MAP[-1]
    
    def _input_value_to_protocol_value(self, input_value: int) -> int:
        """将输入值转换为协议频率值
        
        根据协议文档，将输入值范围(10~1000)转换为波形频率协议值(10~240)
        
        协议转换算法：
        - 10-100: 直接使用输入值
        - 101-600: (输入值 - 100)/5 + 100
        - 601-1000: (输入值 - 600)/10 + 200
        
        Args:
            input_value: 输入值(10-1000)，来自.pulse文件的频率滑块映射
            
        Returns:
            int: 协议频率值(10-240)
        """
        # 限制输入范围
        input_value = max(10, min(1000, input_value))
        
        # 根据协议算法转换
        if 10 <= input_value <= 100:
            protocol_value = input_value
        elif 101 <= input_value <= 600:
            protocol_value = int((input_value - 100) / 5) + 100
        elif 601 <= input_value <= 1000:
            protocol_value = int((input_value - 600) / 10) + 200
        else:
            protocol_value = 10
        
        # 确保在有效范围内
        return max(10, min(240, protocol_value))
    
    def _validate_protocol_range(self, protocol_value: int) -> int:
        """验证并限制协议频率值在有效范围内
        
        协议要求频率值在10-240范围内
        
        Args:
            protocol_value: 协议频率值
            
        Returns:
            int: 限制后的协议频率值
        """
        return max(PulseFileConstants.PROTOCOL_FREQ_MIN, min(PulseFileConstants.PROTOCOL_FREQ_MAX, protocol_value))
    
    def _slider_to_section_time(self, slider_value: int) -> float:
        """将小节时长滑块值转换为实际时长（秒）"""
        if 0 <= slider_value < len(PulseFileConstants.SECTION_TIME_MAP):
            return PulseFileConstants.SECTION_TIME_MAP[slider_value]
        else:
            # 超出范围时使用边界值
            if slider_value < 0:
                return PulseFileConstants.SECTION_TIME_MAP[0]
            else:
                return PulseFileConstants.SECTION_TIME_MAP[-1]
    
    def convert_to_pulse_operations(self, header: PulseFileHeader, sections: List[PulseSection]) -> List[PulseOperation]:
        """将解析的数据转换为PulseOperation列表
        
        Args:
            header: 文件头部信息
            sections: 小节列表
            
        Returns:
            List[PulseOperation]: 转换后的波形操作列表
        """
        pulse_operations = []
        
        for section in sections:
            if not section.enabled:
                continue
            
            # 根据频率模式生成脉冲操作
            section_operations = self._generate_section_operations(section, header.speed_multiplier)
            pulse_operations.extend(section_operations)
        
        return pulse_operations
    
    def _generate_section_operations(self, section: PulseSection, speed_multiplier: int) -> List[PulseOperation]:
        """为单个小节生成脉冲操作
        
        根据郊狼App格式，小节时长控制脉冲元的重复播放时间。
        脉冲元总是会重复完整个循环之后再停止。
        
        speed_multiplier的作用：
        - 1: 正常速度播放（100ms为一个脉冲，对应PulseOperation的4个25ms子步骤）
        - 2: 2倍速播放（50ms为一个脉冲，对应PulseOperation的2个25ms子步骤）
        - 4: 4倍速播放（25ms为一个脉冲，对应PulseOperation的1个25ms子步骤）
        """
        operations = []
        
        # 1. 验证速度倍率
        if speed_multiplier not in [1, 2, 4]:
            raise ValueError(f"无效的速度倍率: {speed_multiplier}，可接受值为1, 2, 4")
        
        # 2. 计算脉冲元的实际长度（根据脉冲数据和速度倍率）
        pulse_element_duration = self._calculate_pulse_element_duration(section.pulse_data, speed_multiplier)
        
        # 3. 计算循环次数（向上取整）
        import math
        cycles = math.ceil(section.section_duration / pulse_element_duration)
        
        # 3. 根据频率模式生成操作
        if section.frequency_mode == FrequencyMode.ELEMENT_INTER_GRADIENT:
            # 元间渐变：需要为每个脉冲元计算不同的频率
            operations = self._generate_element_inter_gradient_operations(section, cycles, speed_multiplier)
        else:
            # 其他模式：生成单个脉冲元然后重复
            # 重复脉冲元直到达到小节时长
            for cycle in range(cycles):
                pulse_element_operations = self._generate_pulse_element_operations(section, speed_multiplier, cycle, cycles)
                operations.extend(pulse_element_operations)
        
        # 4. 截取到精确的小节时长
        target_steps = int(section.section_duration * 10)  # 转换为100ms步数
        operations = operations[:target_steps]
        
        return operations
    
    def _generate_element_inter_gradient_operations(self, section: PulseSection, cycles: int, speed_multiplier: int) -> List[PulseOperation]:
        """生成元间渐变模式的操作
        
        元间渐变：第一个脉冲元到最后一个脉冲元从频率A渐变到频率B
        """
        operations = []
        
        for cycle in range(cycles):
            # 计算当前脉冲元的频率（在频率A和频率B之间渐变）
            if cycles > 1:
                progress = cycle / (cycles - 1)
                current_frequency = self._interpolate_frequency(section.freq_a, section.freq_b, progress)
            else:
                current_frequency = self._convert_frequency_to_protocol(section.freq_a)
            
            # 生成当前脉冲元的操作
            pulse_element_operations = self._generate_pulse_element_operations_with_frequency(section, current_frequency, speed_multiplier, cycle, cycles)
            operations.extend(pulse_element_operations)
        
        return operations
    
    def _generate_pulse_element_operations_with_frequency(self, section: PulseSection, frequency: int, speed_multiplier: int, cycle_index: int = 0, total_cycles: int = 1) -> List[PulseOperation]:
        """使用指定频率生成脉冲元操作"""
        if not section.pulse_data:
            # 如果没有脉冲数据，生成默认的脉冲元
            return self._generate_default_pulse_operations(frequency, speed_multiplier)
        
        # 根据脉冲数据和速度倍率生成操作
        operations = []
        
        for pulse_index, pulse_item in enumerate(section.pulse_data):
            # 根据速度倍率决定是否生成PulseOperation
            if self._should_generate_operation(pulse_index, speed_multiplier):
                # 获取压缩后的脉冲数据项
                compressed_items = self._get_compressed_pulse_items(section.pulse_data, pulse_index, speed_multiplier)
                
                # 创建PulseOperation（使用指定频率）
                operation = self._create_pulse_operation_from_items(frequency, compressed_items)
                operations.append(operation)
        
        return operations
    
    def _calculate_pulse_element_duration(self, pulse_data: List[PulseDataItem], speed_multiplier: int) -> float:
        """计算脉冲元的实际长度（秒）
        
        根据郊狼App格式，脉冲元由最少两根"竖条"组成，
        每根竖条代表0.1s的输出强度，也就是每个脉冲元的最短长度为0.2秒。
        
        speed_multiplier影响播放速度：
        - 1: 正常速度，每个脉冲数据项代表0.1秒
        - 2: 2倍速，每个脉冲数据项代表0.05秒（50ms）
        - 4: 4倍速，每个脉冲数据项代表0.025秒（25ms）
        """
        if not pulse_data:
            return PulseFileConstants.MIN_PULSE_ELEMENT_DURATION / speed_multiplier  # 最小脉冲元长度按速度倍率调整
        
        # 根据速度倍率计算每个脉冲数据项的时间
        time_per_item = PulseFileConstants.BASE_TIME_PER_ITEM / speed_multiplier
        
        return len(pulse_data) * time_per_item
    
    def _generate_pulse_element_operations(self, section: PulseSection, speed_multiplier: int, cycle_index: int = 0, total_cycles: int = 1) -> List[PulseOperation]:
        """生成单个脉冲元的操作列表
        
        speed_multiplier决定每个脉冲数据项对应多少个PulseOperation：
        - 1: 每个脉冲数据项对应1个PulseOperation（100ms）
        - 2: 每个脉冲数据项对应0.5个PulseOperation（50ms）
        - 4: 每个脉冲数据项对应0.25个PulseOperation（25ms）
        
        Args:
            section: 脉冲小节信息
            speed_multiplier: 速度倍率
            cycle_index: 当前脉冲元索引（用于元间渐变）
            total_cycles: 总脉冲元数量（用于元间渐变）
        """
        operations = []
        
        if not section.pulse_data:
            # 如果没有脉冲数据，生成默认的脉冲元
            input_value = self._slider_to_frequency(section.freq_a)
            protocol_value = self._input_value_to_protocol_value(input_value)
            frequency = self._validate_protocol_range(protocol_value)
            
            # 生成默认脉冲元操作
            return self._generate_default_pulse_operations(frequency, speed_multiplier)
        
        # 根据脉冲数据和速度倍率生成操作
        return self._generate_pulse_operations_from_data(section, speed_multiplier, cycle_index, total_cycles)
    
    def _generate_default_pulse_operations(self, frequency: int, speed_multiplier: int) -> List[PulseOperation]:
        """生成默认脉冲元操作（无脉冲数据时）"""
        operations = []
        
        # 根据速度倍率生成操作（默认脉冲元长度为0.2秒）
        if speed_multiplier == 1:
            # 生成2个100ms步骤（0.2秒）
            for _ in range(2):
                operations.append(self._create_pulse_operation(frequency, 0))
        elif speed_multiplier == 2:
            # 生成4个50ms步骤（0.2秒）
            for _ in range(4):
                operations.append(self._create_pulse_operation(frequency, 0))
        elif speed_multiplier == 4:
            # 生成8个25ms步骤（0.2秒）
            for _ in range(8):
                operations.append(self._create_pulse_operation(frequency, 0))
        
        return operations
    
    def _generate_pulse_operations_from_data(self, section: PulseSection, speed_multiplier: int, cycle_index: int = 0, total_cycles: int = 1) -> List[PulseOperation]:
        """根据脉冲数据生成操作"""
        operations = []
        
        for pulse_index, pulse_item in enumerate(section.pulse_data):
            # 根据速度倍率决定是否生成PulseOperation
            if self._should_generate_operation(pulse_index, speed_multiplier):
                # 获取压缩后的脉冲数据项
                compressed_items = self._get_compressed_pulse_items(section.pulse_data, pulse_index, speed_multiplier)
                
                # 根据频率模式创建PulseOperation
                if section.frequency_mode == FrequencyMode.ELEMENT_GRADIENT:
                    # 元内渐变：使用特殊的创建方法
                    operation = self._create_pulse_operation_with_element_gradient(section, compressed_items, speed_multiplier)
                else:
                    # 其他模式：根据频率模式计算频率
                    frequency = self._calculate_pulse_frequency(section, pulse_item, pulse_index, cycle_index, total_cycles)
                    operation = self._create_pulse_operation_from_items(frequency, compressed_items)
                
                operations.append(operation)
        
        return operations
    
    def _should_generate_operation(self, pulse_index: int, speed_multiplier: int) -> bool:
        """判断是否应该生成PulseOperation"""
        if speed_multiplier == 1:
            return True  # 每个脉冲数据项都生成
        elif speed_multiplier == 2:
            return pulse_index % 2 == 0  # 每2个脉冲数据项生成1个
        elif speed_multiplier == 4:
            return pulse_index % 4 == 0  # 每4个脉冲数据项生成1个
        return False
    
    def _get_compressed_pulse_items(self, pulse_data: List[PulseDataItem], start_index: int, speed_multiplier: int) -> List[PulseDataItem]:
        """获取压缩后的脉冲数据项"""
        if speed_multiplier == 1:
            return [pulse_data[start_index]]
        elif speed_multiplier == 2:
            # 获取2个脉冲数据项
            items = pulse_data[start_index:start_index + 2]
            if len(items) < 2:
                items.append(pulse_data[start_index])  # 用当前项填充
            return items
        elif speed_multiplier == 4:
            # 获取4个脉冲数据项
            items = pulse_data[start_index:start_index + 4]
            while len(items) < 4:
                items.append(pulse_data[start_index])  # 用当前项填充
            return items
        return [pulse_data[start_index]]
    
    def _create_pulse_operation(self, frequency: int, intensity: int) -> PulseOperation:
        """创建单个PulseOperation"""
        freq_tuple = (frequency, frequency, frequency, frequency)
        intensity_tuple = (intensity, intensity, intensity, intensity)
        return (freq_tuple, intensity_tuple)
    
    def _create_pulse_operation_from_items(self, frequency: int, items: List[PulseDataItem]) -> PulseOperation:
        """从脉冲数据项列表创建PulseOperation"""
        freq_tuple = (frequency, frequency, frequency, frequency)
        intensity_tuple = (
            items[0].intensity if len(items) > 0 else 0,
            items[1].intensity if len(items) > 1 else 0,
            items[2].intensity if len(items) > 2 else 0,
            items[3].intensity if len(items) > 3 else 0
        )
        return (freq_tuple, intensity_tuple)
    
    def _create_pulse_operation_with_element_gradient(self, section: PulseSection, items: List[PulseDataItem], speed_multiplier: int) -> PulseOperation:
        """创建带有元内渐变的PulseOperation
        
        元内渐变：在PulseOperation的4个25ms子步骤内从频率A渐变到频率B
        根据速度倍率决定渐变的子步骤数量：
        - speed_multiplier=1: 4个子步骤都参与渐变
        - speed_multiplier=2: 2个子步骤参与渐变
        - speed_multiplier=4: 1个子步骤，无法渐变
        """
        # 根据速度倍率确定参与渐变的子步骤数量
        if speed_multiplier == 1:
            gradient_steps = 4
        elif speed_multiplier == 2:
            gradient_steps = 2
        elif speed_multiplier == 4:
            gradient_steps = 1
        else:
            gradient_steps = 4
        
        # 计算渐变频率
        freq_a_protocol = self._convert_frequency_to_protocol(section.freq_a)
        freq_b_protocol = self._convert_frequency_to_protocol(section.freq_b)
        
        if gradient_steps == 1:
            # 无法渐变，使用固定频率
            freq_tuple = (freq_a_protocol, freq_a_protocol, freq_a_protocol, freq_a_protocol)
        else:
            # 生成渐变频率
            frequencies = []
            for i in range(4):
                if i < gradient_steps:
                    progress = i / (gradient_steps - 1) if gradient_steps > 1 else 0
                    freq = int(freq_a_protocol + (freq_b_protocol - freq_a_protocol) * progress)
                    freq = self._validate_protocol_range(freq)
                else:
                    # 超出渐变步数的部分使用最后一个渐变值
                    progress = 1.0
                    freq = int(freq_a_protocol + (freq_b_protocol - freq_a_protocol) * progress)
                    freq = self._validate_protocol_range(freq)
                frequencies.append(freq)
            freq_tuple = tuple(frequencies)
        
        # 强度元组
        intensity_tuple = (
            items[0].intensity if len(items) > 0 else 0,
            items[1].intensity if len(items) > 1 else 0,
            items[2].intensity if len(items) > 2 else 0,
            items[3].intensity if len(items) > 3 else 0
        )
        
        return (freq_tuple, intensity_tuple)
    
    def _calculate_pulse_frequency(self, section: PulseSection, pulse_item: PulseDataItem, pulse_index: int, cycle_index: int = 0, total_cycles: int = 1) -> int:
        """计算单个脉冲的频率（返回协议频率值10-240）"""
        # 根据频率模式计算频率
        total_pulses = len(section.pulse_data) if section.pulse_data else 1
        return self._calculate_section_frequency_with_mode(section, pulse_index, total_pulses, cycle_index, total_cycles)
    
    def _calculate_section_frequency_with_mode(self, section: PulseSection, pulse_index: int, total_pulses: int, cycle_index: int = 0, total_cycles: int = 1, global_pulse_index: int = 0, total_section_pulses: int = 1) -> int:
        """根据频率模式计算脉冲频率（返回协议频率值10-240）
        
        Args:
            section: 脉冲小节信息
            pulse_index: 当前脉冲在脉冲元中的索引
            total_pulses: 脉冲元中的总脉冲数
            cycle_index: 当前脉冲元的循环索引
            total_cycles: 总循环数
            global_pulse_index: 当前脉冲在整个小节中的全局索引
            total_section_pulses: 整个小节的总脉冲数
        """
        if section.frequency_mode == FrequencyMode.FIXED:
            # 固定模式：使用频率A
            return self._convert_frequency_to_protocol(section.freq_a)
        
        elif section.frequency_mode == FrequencyMode.SECTION_GRADIENT:
            # 节内渐变：在整个小节的持续时间内从频率A渐变到频率B
            # 跨越所有重复的脉冲元，从小节开始到小节结束
            if total_section_pulses > 1:
                progress = global_pulse_index / (total_section_pulses - 1)
            else:
                progress = 0
            return self._interpolate_frequency(section.freq_a, section.freq_b, progress)
        
        elif section.frequency_mode == FrequencyMode.ELEMENT_GRADIENT:
            # 元内渐变：每个脉冲元内部从频率A渐变到频率B（周期性变化）
            # 在每个脉冲元的持续时间内进行渐变，多个脉冲元重复这个周期
            pulse_element_length = len(section.pulse_data) if section.pulse_data else 1
            if pulse_element_length > 1:
                # 计算当前脉冲在脉冲元中的相对位置
                element_pulse_index = pulse_index % pulse_element_length
                progress = element_pulse_index / (pulse_element_length - 1)
                return self._interpolate_frequency(section.freq_a, section.freq_b, progress)
            else:
                return self._convert_frequency_to_protocol(section.freq_a)
        
        elif section.frequency_mode == FrequencyMode.ELEMENT_INTER_GRADIENT:
            # 元间渐变：每个脉冲元内部频率固定，但不同脉冲元之间从频率A渐变到频率B
            # 第一个脉冲元到最后一个脉冲元的频率渐变
            if total_cycles > 1:
                progress = cycle_index / (total_cycles - 1)
                return self._interpolate_frequency(section.freq_a, section.freq_b, progress)
            else:
                return self._convert_frequency_to_protocol(section.freq_a)
        
        else:
            return self._convert_frequency_to_protocol(section.freq_a)
    
    def _convert_frequency_to_protocol(self, freq_slider: int) -> int:
        """将频率滑块值转换为协议频率值"""
        input_value = self._slider_to_frequency(freq_slider)
        protocol_value = self._input_value_to_protocol_value(input_value)
        return self._validate_protocol_range(protocol_value)
    
    def _interpolate_frequency(self, freq_a_slider: int, freq_b_slider: int, progress: float) -> int:
        """在两个频率之间进行插值计算"""
        freq_a_input = self._slider_to_frequency(freq_a_slider)
        freq_b_input = self._slider_to_frequency(freq_b_slider)
        interpolated_input = int(freq_a_input + (freq_b_input - freq_a_input) * progress)
        protocol_value = self._input_value_to_protocol_value(interpolated_input)
        return self._validate_protocol_range(protocol_value)
```

### 4.2 扩展导入对话框

修改`src/gui/pulse/pulse_dialogs.py`，在`ImportPulseDialog`中添加第三个标签页：

```python
def create_pulse_file_import_tab(self) -> QWidget:
    """创建.pulse文件导入标签页"""
    tab = QWidget()
    layout = QVBoxLayout(tab)
    
    # 文件选择
    file_layout = QHBoxLayout()
    
    self.pulse_file_path_edit = QLineEdit()
    self.pulse_file_path_edit.setPlaceholderText("请选择.pulse文件")
    self.pulse_file_path_edit.setReadOnly(True)
    file_layout.addWidget(self.pulse_file_path_edit)
    
    browse_pulse_btn = QPushButton("浏览...")
    browse_pulse_btn.clicked.connect(self.browse_pulse_file)
    file_layout.addWidget(browse_pulse_btn)
    
    layout.addLayout(file_layout)
    
    # 文件信息显示
    info_label = QLabel("文件信息:")
    layout.addWidget(info_label)
    
    self.pulse_file_info = QTextEdit()
    self.pulse_file_info.setMaximumHeight(120)
    self.pulse_file_info.setReadOnly(True)
    layout.addWidget(self.pulse_file_info)
    
    # 波形预览
    preview_label = QLabel("波形预览:")
    layout.addWidget(preview_label)
    
    self.pulse_file_preview = QTextEdit()
    self.pulse_file_preview.setMaximumHeight(150)
    self.pulse_file_preview.setReadOnly(True)
    layout.addWidget(self.pulse_file_preview)
    
    return tab

def browse_pulse_file(self) -> None:
    """浏览.pulse文件"""
    file_path, _ = QFileDialog.getOpenFileName(
        self, "选择.pulse文件", "", "Pulse文件 (*.pulse);;所有文件 (*)"
    )
    
    if file_path:
        self.pulse_file_path_edit.setText(file_path)
        self.load_pulse_file(file_path)

def load_pulse_file(self, file_path: str) -> None:
    """加载.pulse文件"""
    try:
        from core.pulse_file_parser import PulseFileParser
        
        # 解析文件
        parser = PulseFileParser()
        pulse_data = parser.parse_file(file_path)
        
        # 转换为PulseOperation
        pulse_operations = parser.convert_to_pulse_operations(pulse_data.header, pulse_data.sections)
        
        # 显示文件信息
        info_text = f"休息时长: {pulse_data.header.rest_duration:.1f}秒\n"
        info_text += f"速度倍率: {pulse_data.header.speed_multiplier}x\n"
        info_text += f"未知参数: {pulse_data.header.unknown_param}\n"
        info_text += f"小节数量: {len(pulse_data.sections)}\n"
        info_text += f"启用小节: {sum(1 for s in pulse_data.sections if s.enabled)}\n"
        
        self.pulse_file_info.setText(info_text)
        
        # 显示波形预览
        preview_text = f"总步数: {len(pulse_operations)}\n"
        preview_text += f"持续时间: {len(pulse_operations) * 0.1:.1f}秒\n"
        
        if pulse_operations:
            # 显示前几步的数据
            preview_text += "\n前5步数据:\n"
            for i, (freq, intensity) in enumerate(pulse_operations[:5]):
                preview_text += f"步骤{i+1}: 频率{freq[0]}ms, 强度{intensity[0]}%\n"
        
        self.pulse_file_preview.setText(preview_text)
        
        # 存储解析结果
        self.parsed_pulse_operations = pulse_operations
        
    except Exception as e:
        QMessageBox.critical(self, "解析失败", f"解析.pulse文件失败: {e}")
        self.pulse_file_info.clear()
        self.pulse_file_preview.clear()
        self.parsed_pulse_operations = []
```

### 4.3 更新文件选择对话框

修改`browse_file`方法，支持.pulse文件：

```python
def browse_file(self) -> None:
    """浏览文件"""
    file_path, _ = QFileDialog.getOpenFileName(
        self, translate("pulse_dialogs.import_pulse.select_file"), 
        "", "JSON文件 (*.json);;Pulse文件 (*.pulse);;所有文件 (*)"
    )
    
    if file_path:
        self.file_path_edit.setText(file_path)
        if file_path.endswith('.pulse'):
            self.load_pulse_file(file_path)
        else:
            self.load_pulses(file_path)
```

### 4.4 添加国际化支持

在`src/locales/zh.yml`中添加相关翻译：

```yaml
pulse_dialogs:
  import_pulse:
    # ... 现有翻译 ...
    pulse_file_tab: "从.pulse文件导入"
    select_pulse_file: "请选择.pulse文件"
    pulse_file_info: "文件信息:"
    pulse_file_preview: "波形预览:"
    parse_success: "解析成功"
    parse_failed: "解析失败"
    invalid_pulse_format: "无效的.pulse文件格式"
    unsupported_version: "不支持的.pulse文件版本"
```

## 5. 实现步骤

### 5.1 第一阶段：核心解析器
1. 创建`src/core/pulse_file_parser.py`
2. 实现基本的文件解析功能
3. 添加单元测试

### 5.2 第二阶段：UI集成
1. 修改`ImportPulseDialog`添加.pulse文件标签页
2. 更新文件选择对话框支持.pulse文件
3. 添加国际化支持

### 5.3 第三阶段：功能完善
1. 完善频率模式处理逻辑
2. 优化脉冲数据解析
3. 添加错误处理和用户反馈

### 5.4 第四阶段：测试和优化
1. 使用真实.pulse文件进行测试
2. 性能优化
3. 用户体验改进

## 6. 技术考虑与风险评估

### 6.1 数据转换精度
- 确保滑块值到实际值的映射准确
- 处理边界情况和异常值
- 保持与官方APP的一致性
- **协议兼容性**：确保频率值在10-240协议数值范围内

### 6.2 频率模式处理
- 固定模式：直接使用频率A
- 渐变模式：需要实现插值算法
- 复杂模式：可能需要更精细的处理逻辑
- **协议映射**：将10-1000ms映射到10-240协议数值范围

### 6.3 协议兼容性
- **频率范围验证**：确保所有频率值在协议支持的10-240范围内
- **频率映射精度**：10-1000ms到10-240的线性映射精度
- **强度范围验证**：确保强度值在0-100范围内
- **设备兼容性**：超出范围的值会被设备忽略，需要提前过滤
- **软上限考虑**：导入后可能需要设置合适的强度软上限

### 6.4 错误处理
- 文件格式验证
- 数据范围检查
- 协议兼容性检查
- 用户友好的错误提示

### 6.5 性能优化
- 大文件解析优化
- 内存使用控制
- 异步处理支持
- 频率范围验证优化

### 6.6 技术风险
- 频率模式处理复杂，可能影响转换准确性
- 脉冲数据解析逻辑可能不完整
- 性能问题，特别是大文件处理
- **协议兼容性风险**：频率值超出10-240协议数值范围导致设备忽略

### 6.7 兼容性风险
- 不同版本的.pulse文件格式差异
- 官方APP更新可能导致格式变化
- **协议兼容性风险**：.pulse文件中的频率值映射到协议可能精度损失
- **设备兼容性风险**：导入的波形在设备上可能表现异常

### 6.8 数据完整性风险
- 频率值映射后可能改变原始波形特征
- 10-1000ms到10-240的映射可能导致精度损失
- 强度软上限可能影响波形的实际效果

### 6.9 缓解措施
- 实现灵活的解析器架构
- 添加版本检测和兼容性处理
- 提供详细的错误信息和用户指导
- **协议兼容性检查**：在导入时验证并警告超出范围的频率值
- **频率映射优化**：使用高精度线性映射算法，减少精度损失
- **数据完整性保护**：提供频率值调整选项，保持波形特征
- **设备测试**：提供波形预览和测试功能

## 7. 测试计划

### 7.1 单元测试
- 文件解析器各个方法的测试
- 数据转换准确性测试
- 边界条件测试
- **协议兼容性测试**：频率范围验证、强度范围验证
- **频率转换测试**：滑块值到毫秒值的转换准确性

### 7.2 集成测试
- 完整导入流程测试
- UI交互测试
- 错误处理测试
- **协议集成测试**：确保导入的波形与协议完全兼容

### 7.3 设备兼容性测试
- 使用真实设备测试导入的波形
- 验证频率值在设备上的实际表现
- 测试超出范围值的处理
- 验证强度软上限的影响

### 7.4 用户测试
- 真实.pulse文件导入测试
- 不同频率模式测试
- 用户体验测试
- **协议兼容性验证**：确保导入的波形在设备上正常工作

## 8. 总结

本方案提供了完整的.pulse文件导入功能实现路径，包括：

1. **核心解析器**：处理文件格式解析和数据转换，正确实现脉冲元循环机制
2. **UI集成**：扩展现有导入对话框，支持.pulse文件导入
3. **错误处理**：完善的异常处理和用户反馈
4. **测试计划**：确保功能稳定可靠

通过分阶段实施，可以逐步完善功能，确保与现有系统的良好集成，为用户提供与官方APP一致的波形体验。
